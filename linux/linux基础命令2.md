## linux基础命令

```
dd 命令详解：
    dd if=输入文件 of=输出文件 bs=字节数 count=个数
touch 命令详解：
   touch -a -c -d -m :-d 我试过有些作用
stat 命令详解：
    stat -f file 查看这个文件在文件系统中的信息
date 命令详解：
    date +%Y-%m-%d  %H%M%S
    date +%w %w                                         #查看当前
    
查看文件命令：
    cat     more    less    head    tail    
    tail -f                                                     #可以用来监视文件
ln  命令详解：
    *  链接命令
    ln [选项]     源文件     目标文件
        选项：
            -s  设置软连接
            -f  强制：如果文件已存在，删除文件，然后再建立文件
cp 命令详解：
    * 复制命令：
    cp [选项]     源文件     目标文件
    选项：
        -a == -dpr
        -d 复制软连接，如果目标是硬链接无效
        -i 询问，如果目标文件存在则会询问是否覆盖
        -l 建立连接文件而不是复制源文件
        -s 建立目标文件软连接文件，不是复制源文件
        -p 目标文件保留源文件属性
        -r 递归复制，用于复制目录
mv 命令详解：
    * 移动和重命名文件：
    选项：
        -f 强制覆盖
        -v 显示过程
        -n 不覆盖已存在文件
```

## 权限管理命令

```
chmod 命令详解：
    chmod [选项]  权限模式    文件名
        -R 递归
    rwx 读写执行权限
    对于目录的rwx权限：r 读     w 写相当于最高权限（可以修改目录文件 ）    x 可以进入目录
    对于文件的rwx权限：r 读      w 写     x 执行    文件的最高权限
```

## 下载命令

```
wget 命令详解：
    wget $url -r -R index*,gordon* -nd -np -l1 -P ~/ww37 --no-proxy  --no-check-certificate
    下载当前目录下说有的文件
```

## 进程管理命令

```
pidof： 查看莫个进程ID eg： pidof sshd
kill：    提供进程号杀死
killall： 提供服务名杀死
```

## 替换命令

```
tr 命令详解：
    用于替换文件中的字符
```

## 帮助信息命令

```
man 命令详解：
    man -f cmd  查看命令用拥有的等级                      whatis == man -f
    man -k cmd 查看命令中包含指定字符串相关命令       aproprs == man -k
```

## 搜索命令

```
whereis 命令详解：
    搜索系统命令的命令：
    whereis 【-b -m】 cmd
which cmd 类似 whereis -b cmd
locate 命令详解：
    locate file
    locate查看的数据库并不是直接搜索硬盘
    updatedb可以更新locate的数据库
find 命令详解：
    -name           按照文件名搜索
    -iname          按照文件名搜索，不区分文件大小写
    -inum           按照iNode号搜索
    find命令是完全匹配的，必须和搜素关键字一模一样才能匹配到
    find -size **k 
    find -size **M
    find -atime [+-] 时间 按照文件访问时间搜索
    find -mtime [+-] 时间 按照文件数据修改时间搜索
    find -ctime [+-]  时间 按照文件状态修改时间搜索
        -5 表示5天内修改的文件
        +5 表示6天前修改的文件
        5 表示5-6那一天修改的文件
    find按权限：
    find -perm 666 表示要完全一样才能匹配上
    find -perm -666 表示要全部包含才能匹配到
    find -perm +666 表示包含其中一位即可
    find按所有者和所有组
    find -uid 
    find -gid
    find -user
    find -group 
    find -nouser
    find 按文件类型搜索
    find -type d 目录
    find -type f 文件
    find -type l 链接文件
    
    find 逻辑运算符
    -a and逻辑与
    -o or逻辑或
    -not not逻辑非
    
    find 搜索路径 搜索内容 -exec 命令 {} \;
    find 搜索路径 搜索内容 -ok 命令 {} \; 执行命令会询问
```

## 网络命令

```
netstat 命令详解：
    网络状态查看命令
    -a 列出所有网络状态
    -c 秒数，每隔几秒刷新
```

## shell编程

```
shell数组
    数组赋值
    array_name=（1 2 3 4）*中间用空格隔开
    也可以单独定义各个单独数组变量
    array_name[0]=value0
    array_name[1]=value1
    array_name[2]=value2
    array_name[n]=valuen
    读取数组：
        ${数组名【下标】}
    使用@符号获取数组中的所有元素 

shell中if条件字符串、数字比对，[[ ]]和[ ]区别
```

> shell  括号学习shell的时候总是被shell里的条件判断方式搞得头疼，经常不知道改  用[],[[]],(())还是test,let，而很少有书把它们的关系讲解的很清楚(应该是我悟性差或是看书太少)，今天总结一下，基础的东西如它们  的使用方法不再赘述，重点说说它们的区别的使用时应该注意的地方。
>  先说[]和test，两者是一样的，在命令行里test expr和[ expr ]的效果相同。test的三个基本作用是判断文件、判断字符串、判断整数。支持使用与或非将表达式连接起来。要注意的有：
>  1.test中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq,  -gt这种形式。无论是字符串比较还是整数比较都千万不要使用大于号小于号。当然，如果你实在想用也是可以的，对于字符串比较可以使用尖括号的转义形式，  如果比较"ab"和"bc"：[ ab < bc ]，结果为真，也就是返回状态为0.
>  然后是[[  ]]，这是内置在shell中的一个命令，它就比刚才说的test强大的多了。支持字符串的模式匹配（使用=~操作符时甚至支持shell的正则表达  式）。简直强大的令人发指！逻辑组合可以不使用test的-a,-o而使用&&,||这样更亲切的形式(针对c、Java程序员)。当  然，也不用想的太复杂，基本只要记住
>  1.字符串比较时可以把右边的作为一个模式（这是右边的字符串不加双引号的情况下。如果右边的字符串加了双引号，则认为是一个文本字符串。），而不仅仅是一个字符串，比如[[  hello == hell? ]]，结果为真。另外要注意的是，使用[]和[[]]的时候不要吝啬空格，每一项两边都要有空格，[[ 1 == 2  ]]的结果为“假”，但[[ 1==2 ]]的结果为“真”！后一种显然是错的
>  3.最后就是let和(())，两者也是一样的(或者说基本上是一样的，双括号比let稍弱一些)。主要进行算术运算(上面的两个都不行)，也比较适合进  行整数比较，可以直接使用熟悉的<,>等比较运算符。可以直接使用变量名如var而不需要$var这样的形式。支持分号隔开的多个表达式

------

> 1. 首先，尽管很相似，但是从概念上讲，二者是不同层次的东西。
>     "[["，是关键字，许多shell(如ash bsh)并不支持这种方式。ksh, bash(据说从2.02起引入对[[的支持)等支持。
>     "["是一条命令， 与test等价，大多数shell都支持。在现代的大多数sh实现中，"["与"test"是内部(builtin)命令，换句话说执行"test"/"["时不会调用/some/path/to/test这样的外部命令(如果有这样的命令的话)。
>     2.[[]]结构比Bash版本的[]更通用。在[[和]]之间的所有的字符都不会被文件扩展或是标记分割，但是会有参数引用和命令替换。用[[ ... ]]测试结构比用[  ...  ]更能防止脚本里的许多逻辑错误。比如说，&&,||,<和>操作符能在一个[[]]测试里通过，但在[]结构会发生错误。3.((   ))结构扩展并计算一个算术表达式的值。如果表达式值为0，会返回1或假作为退出状态码。一个非零值的表达式返回一个0或真作为退出状态码。这个结构和先前test命令及[]结构的讨论刚好相反。4.[  ... ]为shell命令，所以在其中的表达式应是它的命令行参数，所以串比较操作符">"  与"<"必须转义，否则就变成IO改向操作符了(请参看上面2中的例子)。在[[中"<"与">"不需转义；
>     由于"[["是关键字，不会做命令行扩展，因而相对的语法就稍严格些。例如
>     在[ ... ]中可以用引号括起操作符，因为在做命令行扩展时会去掉这些引号，而在[[ ... ]]则不允许这样做。5.[[ ...  ]]进行算术扩展，而[ ... ]不做6.[[ ... && ... && ...  ]] 和 [ ... -a  ... -a ...] 不一样，[[ ]] 是逻辑短路操作，而 [ ] 不会进行逻辑短路1）在ksh中的test
>     数字的运算可使用let、(( )) ，其中运算时不需要变量符号，运算符为 +、-、*、/、% ，不建议使用expr 数字的比较使用 (( )) ，其运算符 >、>=、<、<=、==、!= 可以使用算术扩展，如：(( 99+1 <= 101 )) 字符表达式的比较使用 [[ ]] ，其运算符 =、!=、-n、-z 文件表达式的测试使用 [[ ]] ，其运算符 -r、-l、-w、-x、-f、-d、-s、-nt、-ot 逻辑表达式的测试使用 [[ ]] ，其运算符 !、&&、|| 数字比较、字符比较、逻辑测试可以组合，如 [[ "a" != "b" && 4 -gt 3 ]]
>     支持bash中的通配符扩展，如：[[ hest = h??t ]] 、[ hest = h*t ]]
>     使用 (( )) 时，不需要空格分隔各值和运算符，使用 [[ ]] 时需要用空格分隔各值和运算符。2）bash与ksh中的 [[ ]] 不同
>     在redhat9的bash中也可以使用 [[ ]] 符号。但是建议严格按照上面的原则使用。
>     在bash中，数字的比较最好使用 (( ))，虽说可以使用 [[ ]]，但若在其内使用运算符  >、>=、<、<=、==、!= 时，其结果经常是错误的，不过若在 [[ ]] 中使用 [ ]  中的运算符“-eq、-ne、-le、-lt、-gt、-ge”等，还尚未发现有错。因此诸如$ [[ " a" != “b” && 4  > 3 ]] 这类组合（见上）也不可以在bash中使用，其出错率很高。
>     例：[[ "a" != "b" && 10 > 2 ]] 判断结果就不正常。
>     诸如 [ 2 < 10 ]、[[ 2 < 10 ]] 都是不要使用。使用算术扩展最好用 (( 99+1 == 100 )) ，而不要使用[[ 99+1 -eq 100 ]] 。

## lsof命令简述：

```
lsof -i:端口
```